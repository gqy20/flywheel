"""Regression tests for issue #2909: TOCTOU symlink vulnerability in _ensure_parent_directory.

Issue: Time-of-check to time-of-use vulnerability between path validation and mkdir.
An attacker could create a symlink at the target location between the existence check
and the mkdir call, potentially causing the application to create directories at
unintended locations or follow symlinks to sensitive paths.

These tests should FAIL before the fix and PASS after the fix.
"""

from __future__ import annotations

import os
import threading
import time
from pathlib import Path

import pytest

from flywheel.storage import TodoStorage
from flywheel.todo import Todo


def test_toctou_symlink_during_mkdir_fails_safely(tmp_path) -> None:
    """Issue #2909: Creating symlink between validation and mkdir should fail safely.

    This tests the TOCTOU race condition by creating a symlink at the target
    location after validation but before mkdir. The fix should handle EEXIST
    from mkdir directly rather than relying on pre-validation.

    Before fix: mkdir may follow symlink and create directory at unintended location
    After fix: Operation fails safely with clear error message
    """
    # Set up a target path that will need parent directory creation
    db_path = tmp_path / "level1" / "level2" / "todo.json"

    # Create a file outside the target that we'll try to point to via symlink
    outside_file = tmp_path / "sensitive_data.txt"
    outside_file.write_text("sensitive content")

    # Create a symlink at the parent directory location that points outside
    # This simulates an attacker placing a symlink during the race window
    symlink_target = tmp_path / "level1"
    symlink_target.symlink_to(outside_file)

    # Now try to save - the parent 'level1' is a symlink to a file
    storage = TodoStorage(str(db_path))

    # Should fail safely - either because symlink exists (EEXIST handling)
    # or because the path component is not a directory
    with pytest.raises((ValueError, OSError, FileExistsError)) as exc_info:
        storage.save([])

    # Verify we get a meaningful error
    error_msg = str(exc_info.value).lower()
    assert any(word in error_msg for word in ["file", "directory", "path", "exists"]), \
        f"Error message should indicate path problem: {exc_info.value}"


def test_toctou_symlink_to_directory_fails_safely(tmp_path) -> None:
    """Issue #2909: Symlink pointing to existing directory should also fail safely.

    Even if a symlink points to a valid directory, we should not follow it
    during parent directory creation to prevent directory traversal attacks.
    """
    # Create a directory outside the target path
    outside_dir = tmp_path / "outside_dir"
    outside_dir.mkdir()
    sensitive_file = outside_dir / "secret.txt"
    sensitive_file.write_text("secret data")

    # Create a symlink inside our target area pointing to outside
    symlink_path = tmp_path / "attacker_link"
    symlink_path.symlink_to(outside_dir)

    # Try to create db at symlink/subdir/todo.json
    db_path = symlink_path / "subdir" / "todo.json"
    storage = TodoStorage(str(db_path))

    # With proper EEXIST handling, this should fail because symlink exists
    # (not follow the symlink to create directories in outside_dir)
    with pytest.raises((ValueError, OSError, FileExistsError)):
        storage.save([])


def test_normal_mkdir_still_works(tmp_path) -> None:
    """Issue #2909: Normal nested directory creation should still work after fix.

    This is a regression test to ensure the fix doesn't break normal functionality.
    """
    db_path = tmp_path / "a" / "b" / "c" / "todo.json"
    storage = TodoStorage(str(db_path))

    # Should succeed without issues
    storage.save([Todo(id=1, text="test")])

    # Verify file was created
    assert db_path.exists()
    assert db_path.parent.is_dir()


def test_concurrent_mkdir_safe(tmp_path) -> None:
    """Issue #2909: Concurrent directory creation should be safe (no TOCTOU race).

    When multiple threads try to create the same parent directories concurrently,
    the operation should either succeed (one creates) or fail safely (others see EEXIST).
    """
    results: list[Exception | None] = []
    db_path = tmp_path / "shared" / "deep" / "todo.json"

    def create_and_save():
        try:
            storage = TodoStorage(str(db_path))
            storage.save([])
            results.append(None)  # Success
        except Exception as e:
            results.append(e)

    # Start multiple threads trying to create the same directory structure
    threads = [threading.Thread(target=create_and_save) for _ in range(5)]
    for t in threads:
        t.start()
    for t in threads:
        t.join()

    # At least one should succeed
    successes = sum(1 for r in results if r is None)
    assert successes >= 1, f"At least one thread should succeed, got {successes}/5"

    # Failures should be safe (not corrupt state)
    failures = [r for r in results if r is not None]
    for f in failures:
        # Should be OSError-related, not something worse like AssertionError
        assert isinstance(f, (OSError, FileExistsError, ValueError)), \
            f"Unexpected error type: {type(f).__name__}: {f}"

    # Directory should exist and be valid
    assert db_path.parent.is_dir()


def test_parent_is_file_fails_gracefully(tmp_path) -> None:
    """Issue #2909: When a parent component is a file, should fail gracefully.

    This is a more direct test of the EEXIST/ENOTDIR handling - if a file
    exists where we need a directory, mkdir should fail with ENOTDIR.
    """
    # Create a file where we need a directory
    blocking_file = tmp_path / "blocking"
    blocking_file.write_text("I am a file")

    # Try to create db at blocking/subdir/todo.json
    db_path = blocking_file / "subdir" / "todo.json"
    storage = TodoStorage(str(db_path))

    # Should fail because parent is a file (not a directory)
    with pytest.raises((ValueError, OSError)) as exc_info:
        storage.save([])

    error_msg = str(exc_info.value).lower()
    # Should mention file vs directory conflict
    assert "file" in error_msg or "directory" in error_msg or "not a directory" in error_msg, \
        f"Error should indicate file/directory conflict: {exc_info.value}"
