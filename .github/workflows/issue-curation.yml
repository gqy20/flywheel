name: Issue Curation

on:
  schedule:
    - cron: "50 * * * *"
  workflow_dispatch:
    inputs:
      max_open_issues:
        description: "Target max number of open issues"
        required: false
        default: "20"
        type: string
      circuit_failure_threshold:
        description: "Circuit breaker consecutive failure threshold"
        required: false
        default: "4"
        type: string
      circuit_cooldown_minutes:
        description: "Circuit breaker cooldown window (minutes)"
        required: false
        default: "60"
        type: string

permissions:
  contents: read
  issues: write
  pull-requests: read
  actions: read
  id-token: write

concurrency:
  group: issue-curation
  cancel-in-progress: false

jobs:
  circuit-breaker:
    runs-on: ubuntu-latest
    outputs:
      should_run: ${{ steps.gate.outputs.should_run }}
      reason: ${{ steps.gate.outputs.reason }}
    steps:
      - name: Circuit breaker gate
        id: gate
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          FAILURE_THRESHOLD: ${{ inputs.circuit_failure_threshold || '4' }}
          COOLDOWN_MINUTES: ${{ inputs.circuit_cooldown_minutes || '60' }}
          GH_PAGER: cat
          PAGER: cat
        shell: bash
        run: |
          set -euo pipefail

          wf_file="$(basename "${GITHUB_WORKFLOW_REF%%@*}")"
          runs_json="$(gh api "repos/${GITHUB_REPOSITORY}/actions/workflows/${wf_file}/runs?per_page=30")"

          read -r consecutive last_failed_at <<EOF
          $(echo "$runs_json" | jq -r --argjson current "$GITHUB_RUN_ID" '
            reduce (
              [ .workflow_runs[]
                | select(.id != $current)
                | select(.status == "completed")
              ][]
            ) as $r (
              {"count":0,"last_failed_at":null,"stopped":false};
              if .stopped then .
              elif ($r.conclusion == "failure") then
                {
                  "count": (.count + 1),
                  "last_failed_at": (.last_failed_at // $r.updated_at),
                  "stopped": false
                }
              else
                {
                  "count": .count,
                  "last_failed_at": .last_failed_at,
                  "stopped": true
                }
              end
            ) | "\(.count) \(.last_failed_at // "none")"
          ')
          EOF

          if [ "$consecutive" -ge "$FAILURE_THRESHOLD" ] && [ "$last_failed_at" != "none" ]; then
            now_epoch="$(date -u +%s)"
            fail_epoch="$(date -u -d "$last_failed_at" +%s)"
            elapsed_min="$(( (now_epoch - fail_epoch) / 60 ))"
            if [ "$elapsed_min" -lt "$COOLDOWN_MINUTES" ]; then
              echo "should_run=false" >> "$GITHUB_OUTPUT"
              echo "reason=cooldown_active_${elapsed_min}m_after_${consecutive}_failures" >> "$GITHUB_OUTPUT"
              exit 0
            fi
          fi

          echo "should_run=true" >> "$GITHUB_OUTPUT"
          echo "reason=gate_open" >> "$GITHUB_OUTPUT"

  curate:
    needs: circuit-breaker
    if: needs.circuit-breaker.outputs.should_run == 'true'
    runs-on: ubuntu-latest
    timeout-minutes: 20
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Curate issue pool with Claude
        uses: anthropics/claude-code-action@v1
        with:
          anthropic_api_key: ${{ secrets.ANTHROPIC_API_KEY }}
          github_token: ${{ secrets.GITHUB_TOKEN }}
          prompt: |
            Curate open issues for this repository.
            First, load and follow `.claude/skills/flywheel-issue-curation/SKILL.md`.

            Runtime config:
            - Max open issues allowed: ${{ inputs.max_open_issues || '20' }}

            Required behavior:
            1. List current open issues with labels and timestamps.
            2. If open issues are within the limit, do nothing and summarize.
            3. If above limit, close only the required number of issues to reach limit.
            4. Close lower-priority and older issues first.
            5. Never close issues labeled `frozen`.
            6. Add a brief close comment with policy rationale and reopen path.
            7. Post a concise summary comment in workflow output.
          claude_args: |
            --max-turns 20
            --allowedTools "Read,Glob,Grep,LS,Bash(gh issue:*),Bash(git:*)"

      - name: Summary
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          GH_PAGER: cat
          PAGER: cat
        run: |
          echo "### Issue Curation" >> "$GITHUB_STEP_SUMMARY"
          echo "- Open issues after curation: $(gh issue list --state open --json number | jq 'length')" >> "$GITHUB_STEP_SUMMARY"
          echo "- Circuit breaker: ${{ needs.circuit-breaker.outputs.reason }}" >> "$GITHUB_STEP_SUMMARY"
