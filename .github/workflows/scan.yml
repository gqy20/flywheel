name: Scan Issues

on:
  schedule:
    - cron: "0 * * * *" # Every hour at minute 0
  workflow_dispatch:
    inputs:
      max_issues:
        description: "Max issues to create in one run"
        required: false
        default: "5"
        type: string
      target_dir:
        description: "Directory to scan"
        required: false
        default: "src"
        type: string
      circuit_failure_threshold:
        description: "Circuit breaker consecutive failure threshold"
        required: false
        default: "4"
        type: string
      circuit_cooldown_minutes:
        description: "Circuit breaker cooldown window (minutes)"
        required: false
        default: "90"
        type: string

permissions:
  contents: read
  issues: write
  actions: read
  id-token: write

concurrency:
  group: scan-issues
  cancel-in-progress: false

jobs:
  circuit-breaker:
    runs-on: ubuntu-latest
    outputs:
      should_run: ${{ steps.gate.outputs.should_run }}
      reason: ${{ steps.gate.outputs.reason }}
    steps:
      - name: Circuit breaker gate
        id: gate
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          FAILURE_THRESHOLD: ${{ inputs.circuit_failure_threshold || '4' }}
          COOLDOWN_MINUTES: ${{ inputs.circuit_cooldown_minutes || '90' }}
          GH_PAGER: cat
          PAGER: cat
        shell: bash
        run: |
          set -euo pipefail

          wf_file="$(basename "${GITHUB_WORKFLOW_REF%%@*}")"
          runs_json="$(gh api "repos/${GITHUB_REPOSITORY}/actions/workflows/${wf_file}/runs?per_page=30")"

          read -r consecutive last_failed_at <<EOF
          $(echo "$runs_json" | jq -r --argjson current "$GITHUB_RUN_ID" '
            reduce (
              [ .workflow_runs[]
                | select(.id != $current)
                | select(.status == "completed")
              ][]
            ) as $r (
              {"count":0,"last_failed_at":null,"stopped":false};
              if .stopped then .
              elif ($r.conclusion == "failure") then
                {
                  "count": (.count + 1),
                  "last_failed_at": (.last_failed_at // $r.updated_at),
                  "stopped": false
                }
              else
                {
                  "count": .count,
                  "last_failed_at": .last_failed_at,
                  "stopped": true
                }
              end
            ) | "\(.count) \(.last_failed_at // "none")"
          ')
          EOF

          if [ "$consecutive" -ge "$FAILURE_THRESHOLD" ] && [ "$last_failed_at" != "none" ]; then
            now_epoch="$(date -u +%s)"
            fail_epoch="$(date -u -d "$last_failed_at" +%s)"
            elapsed_min="$(( (now_epoch - fail_epoch) / 60 ))"
            if [ "$elapsed_min" -lt "$COOLDOWN_MINUTES" ]; then
              echo "should_run=false" >> "$GITHUB_OUTPUT"
              echo "reason=cooldown_active_${elapsed_min}m_after_${consecutive}_failures" >> "$GITHUB_OUTPUT"
              exit 0
            fi
          fi

          echo "should_run=true" >> "$GITHUB_OUTPUT"
          echo "reason=gate_open" >> "$GITHUB_OUTPUT"

  scan:
    needs: circuit-breaker
    if: needs.circuit-breaker.outputs.should_run == 'true'
    runs-on: ubuntu-latest
    timeout-minutes: 30

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Run scan with Claude
        uses: anthropics/claude-code-action@v1
        with:
          claude_code_oauth_token: ${{ secrets.ANTHROPIC_AUTH_TOKEN }}
          github_token: ${{ secrets.GITHUB_TOKEN }}
          prompt: |
            Scan repository code and create actionable issues.
            First, load and follow `.claude/skills/flywheel-scan-issues/SKILL.md`.

            Runtime config:
            - MAX_ISSUES: ${{ inputs.max_issues || '5' }}
            - TARGET_DIR: ${{ inputs.target_dir || 'src' }}

            Required behavior:
            1. Scan only files under TARGET_DIR.
            2. Find high-signal problems/opportunities suitable for tracked issues.
            3. Deduplicate against existing open issues by intent/title.
            4. Each created issue must include a stable fingerprint line in body:
               `[fingerprint:<value>]` where value is derived from file + type + normalized symptom.
            5. Create at most MAX_ISSUES new issues for this run.
            6. Apply one priority label (`p0`/`p1`/`p2`/`p3`) and one type label when possible.
            7. Keep issue body concise: problem, location, impact, expected fix direction.
          claude_args: |
            --max-turns 25
            --model "${{ secrets.ANTHROPIC_MODEL }}"
            --allowedTools "Read,Glob,Grep,LS,Bash(rg:*),Bash(find:*),Bash(gh:*),Bash(git:*)"

      - name: Deduplicate fingerprinted issues
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          GH_PAGER: cat
          PAGER: cat
        shell: bash
        run: |
          set -euo pipefail

          issues_json="$(gh issue list --state open --limit 200 --json number,title,body,createdAt,url)"
          plan="$(
            echo "$issues_json" | jq -r '
              map(
                .fingerprint = (
                  .body
                  | capture("\\[fingerprint:(?<fp>[A-Za-z0-9._-]+)\\]")?
                  | .fp?
                )
              )
              | map(select(.fingerprint != null))
              | sort_by(.fingerprint, .createdAt)
              | group_by(.fingerprint)
              | map(select(length > 1))
              | map({
                  fingerprint: .[0].fingerprint,
                  keep: .[0].number,
                  close: (.[1:] | map(.number))
                })
              | map(select((.close | length) > 0))
              | .[]
              | [.fingerprint, (.keep|tostring), (.close | map(tostring) | join(","))]
              | @tsv
            '
          )"

          if [ -z "$plan" ]; then
            echo "No duplicate fingerprints detected."
            exit 0
          fi

          while IFS=$'\t' read -r fp keep close_csv; do
            [ -z "${close_csv:-}" ] && continue
            for num in $(echo "$close_csv" | tr ',' ' '); do
              [ -z "$num" ] && continue
              gh issue close "$num" \
                --comment "Auto-dedup: duplicate fingerprint \`$fp\`; keeping oldest issue #$keep as canonical." \
                || true
            done
          done <<< "$plan"

      - name: Summary
        env:
          GH_PAGER: cat
          PAGER: cat
        run: |
          echo "### Scan Results" >> $GITHUB_STEP_SUMMARY
          echo "- Issues created: $(gh issue list --state open --json number | jq 'length')" >> $GITHUB_STEP_SUMMARY
          echo "- Circuit breaker: ${{ needs.circuit-breaker.outputs.reason }}" >> $GITHUB_STEP_SUMMARY
