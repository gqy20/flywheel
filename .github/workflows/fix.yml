name: Auto Fix Candidates

on:
  schedule:
    - cron: "30 * * * *"
  workflow_dispatch:
    inputs:
      issue_number:
        description: "Optional: fix a specific issue number"
        required: false
        type: string

permissions:
  contents: write
  pull-requests: write
  issues: write
  actions: read
  id-token: write

concurrency:
  group: auto-fix-candidates
  cancel-in-progress: false

jobs:
  circuit-breaker:
    runs-on: ubuntu-latest
    outputs:
      should_run: ${{ steps.gate.outputs.should_run }}
      reason: ${{ steps.gate.outputs.reason }}
    steps:
      - name: Circuit breaker gate
        id: gate
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          FAILURE_THRESHOLD: "3"
          COOLDOWN_MINUTES: "120"
          GH_PAGER: cat
          PAGER: cat
        shell: bash
        run: |
          set -euo pipefail

          wf_file="$(basename "${GITHUB_WORKFLOW_REF%%@*}")"
          runs_json="$(gh api "repos/${GITHUB_REPOSITORY}/actions/workflows/${wf_file}/runs?per_page=30")"

          read -r consecutive last_failed_at <<EOF
          $(echo "$runs_json" | jq -r --argjson current "$GITHUB_RUN_ID" '
            reduce (
              [ .workflow_runs[]
                | select(.id != $current)
                | select(.status == "completed")
              ][]
            ) as $r (
              {"count":0,"last_failed_at":null,"stopped":false};
              if .stopped then .
              elif ($r.conclusion == "failure") then
                {
                  "count": (.count + 1),
                  "last_failed_at": (.last_failed_at // $r.updated_at),
                  "stopped": false
                }
              else
                {
                  "count": .count,
                  "last_failed_at": .last_failed_at,
                  "stopped": true
                }
              end
            ) | "\(.count) \(.last_failed_at // "none")"
          ')
          EOF

          if [ "$consecutive" -ge "$FAILURE_THRESHOLD" ] && [ "$last_failed_at" != "none" ]; then
            now_epoch="$(date -u +%s)"
            fail_epoch="$(date -u -d "$last_failed_at" +%s)"
            elapsed_min="$(( (now_epoch - fail_epoch) / 60 ))"
            if [ "$elapsed_min" -lt "$COOLDOWN_MINUTES" ]; then
              echo "should_run=false" >> "$GITHUB_OUTPUT"
              echo "reason=cooldown_active_${elapsed_min}m_after_${consecutive}_failures" >> "$GITHUB_OUTPUT"
              exit 0
            fi
          fi

          echo "should_run=true" >> "$GITHUB_OUTPUT"
          echo "reason=gate_open" >> "$GITHUB_OUTPUT"

  select-issue:
    needs: circuit-breaker
    if: needs.circuit-breaker.outputs.should_run == 'true'
    runs-on: ubuntu-latest
    outputs:
      should_run: ${{ steps.pick.outputs.should_run }}
      issue_number: ${{ steps.pick.outputs.issue_number }}
      issue_title: ${{ steps.pick.outputs.issue_title }}
      issue_url: ${{ steps.pick.outputs.issue_url }}
    steps:
      - name: Select next issue
        id: pick
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          INPUT_ISSUE_NUMBER: ${{ inputs.issue_number }}
          GH_PAGER: cat
          PAGER: cat
        shell: bash
        run: |
          set -euo pipefail

          if [ -n "${INPUT_ISSUE_NUMBER:-}" ]; then
            ISSUE_JSON="$(gh issue view "$INPUT_ISSUE_NUMBER" --json number,title,url,state,labels)"
            STATE="$(echo "$ISSUE_JSON" | jq -r '.state')"
            HAS_FROZEN="$(echo "$ISSUE_JSON" | jq -r '[.labels[].name] | any(. == "frozen")')"
            HAS_FAILED="$(echo "$ISSUE_JSON" | jq -r '[.labels[].name] | any(. == "auto-fix-failed")')"
            if [ "$STATE" != "OPEN" ] || [ "$HAS_FROZEN" = "true" ] || [ "$HAS_FAILED" = "true" ]; then
              echo "Specified issue is not eligible for auto-fix."
              echo "should_run=false" >> "$GITHUB_OUTPUT"
              exit 0
            fi
            echo "should_run=true" >> "$GITHUB_OUTPUT"
            echo "issue_number=$(echo "$ISSUE_JSON" | jq -r '.number')" >> "$GITHUB_OUTPUT"
            echo "issue_title=$(echo "$ISSUE_JSON" | jq -r '.title')" >> "$GITHUB_OUTPUT"
            echo "issue_url=$(echo "$ISSUE_JSON" | jq -r '.url')" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          OPEN_PR_ISSUES_JSON="$(
            gh pr list --state open --limit 200 --json title \
            | jq -c '
                map(
                  .title
                  | capture("^\\[AUTOFIX\\]\\[ISSUE-(?<id>[0-9]+)\\]")?
                  | .id?
                  | select(. != null)
                  | tonumber
                )
                | unique
              '
          )"

          ISSUES_JSON="$(gh issue list --state open --limit 100 --json number,title,url,labels)"

          BEST="$(echo "$ISSUES_JSON" | jq -r '
            map(
              .label_names = [.labels[].name]
              | .priority = (
                  if (.label_names | index("p0")) then 0
                  elif (.label_names | index("p1")) then 1
                  elif (.label_names | index("p2")) then 2
                  elif (.label_names | index("p3")) then 3
                  else 99
                  end
                )
            )
            | map(select((.label_names | index("frozen")) | not))
            | map(select((.label_names | index("auto-fix-failed")) | not))
            | map(select((.number as $n | $busy | index($n)) | not))
            | sort_by(.priority, .number)
            | .[0] // empty
          ' --argjson busy "$OPEN_PR_ISSUES_JSON")"

          if [ -z "$BEST" ]; then
            echo "No eligible issue found."
            echo "should_run=false" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          echo "should_run=true" >> "$GITHUB_OUTPUT"
          echo "issue_number=$(echo "$BEST" | jq -r '.number')" >> "$GITHUB_OUTPUT"
          echo "issue_title=$(echo "$BEST" | jq -r '.title')" >> "$GITHUB_OUTPUT"
          echo "issue_url=$(echo "$BEST" | jq -r '.url')" >> "$GITHUB_OUTPUT"

  generate-candidates:
    needs: [circuit-breaker, select-issue]
    if: needs.select-issue.outputs.should_run == 'true'
    runs-on: ubuntu-latest
    timeout-minutes: 60
    strategy:
      fail-fast: false
      matrix:
        candidate_id: [1, 2, 3]
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Generate candidate PR with Claude
        uses: anthropics/claude-code-action@v1
        with:
          anthropic_api_key: ${{ secrets.ANTHROPIC_API_KEY }}
          github_token: ${{ secrets.GITHUB_TOKEN }}
          prompt: |
            You are candidate #${{ matrix.candidate_id }} for fixing issue #${{ needs.select-issue.outputs.issue_number }}.
            First, load and follow the local skill at `.claude/skills/flywheel-candidate-fix/SKILL.md`.

            Issue:
            - Number: #${{ needs.select-issue.outputs.issue_number }}
            - Title: ${{ needs.select-issue.outputs.issue_title }}
            - URL: ${{ needs.select-issue.outputs.issue_url }}

            Required output:
            1. Implement a focused fix using TDD:
               - Add or update a failing regression test first.
               - Implement minimal fix.
               - Run `uv run pytest ...` and `uv run ruff check ...` on changed scope.
            2. Create a branch with EXACT name:
               `claude/issue-${{ needs.select-issue.outputs.issue_number }}-candidate-${{ matrix.candidate_id }}-${{ github.run_id }}`
            3. Commit using conventional commits and include issue number.
            4. Create ONE PR to `master` with EXACT title prefix:
               `[AUTOFIX][ISSUE-${{ needs.select-issue.outputs.issue_number }}][CANDIDATE-${{ matrix.candidate_id }}]`
               followed by a short summary.
            5. PR body must include:
               - Summary of change
               - Tests run
               - Risks/limitations
               - `Closes #${{ needs.select-issue.outputs.issue_number }}`
            6. Never push directly to master.
            7. If blocked, comment on the issue with reason and add label `auto-fix-failed` if label exists.

            Constraints:
            - Keep diff small and reviewable.
            - Do not modify workflows or secrets.
          claude_args: |
            --max-turns 20
            --allowedTools "Edit,MultiEdit,Write,Read,Glob,Grep,LS,Bash(git:*),Bash(gh:*),Bash(uv run pytest:*),Bash(uv run ruff:*)"

      - name: Candidate summary
        if: always()
        run: |
          echo "### Candidate Run" >> "$GITHUB_STEP_SUMMARY"
          echo "- Circuit breaker: ${{ needs.circuit-breaker.outputs.reason }}" >> "$GITHUB_STEP_SUMMARY"
          echo "- Issue: #${{ needs.select-issue.outputs.issue_number }}" >> "$GITHUB_STEP_SUMMARY"
          echo "- Candidate: ${{ matrix.candidate_id }}" >> "$GITHUB_STEP_SUMMARY"
          echo "- Title: ${{ needs.select-issue.outputs.issue_title }}" >> "$GITHUB_STEP_SUMMARY"
