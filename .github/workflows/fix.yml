name: Auto Fix Candidates

on:
  schedule:
    - cron: "30 * * * *"
  workflow_dispatch:
    inputs:
      issue_number:
        description: "Optional: fix a specific issue number"
        required: false
        type: string
      candidate_quality_min_score:
        description: "Minimum quality score required for candidate PR (0-100)"
        required: false
        default: "70"
        type: string
      circuit_failure_threshold:
        description: "Circuit breaker consecutive failure threshold"
        required: false
        default: "3"
        type: string
      circuit_cooldown_minutes:
        description: "Circuit breaker cooldown window (minutes)"
        required: false
        default: "120"
        type: string

permissions:
  contents: write
  pull-requests: write
  issues: write
  actions: read
  id-token: write

concurrency:
  group: auto-fix-candidates
  cancel-in-progress: false

jobs:
  circuit-breaker:
    runs-on: ubuntu-latest
    outputs:
      should_run: ${{ steps.gate.outputs.should_run }}
      reason: ${{ steps.gate.outputs.reason }}
    steps:
      - name: Circuit breaker gate
        id: gate
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          FAILURE_THRESHOLD: ${{ inputs.circuit_failure_threshold || '3' }}
          COOLDOWN_MINUTES: ${{ inputs.circuit_cooldown_minutes || '120' }}
          GH_PAGER: cat
          PAGER: cat
        shell: bash
        run: |
          set -euo pipefail

          wf_file="$(basename "${GITHUB_WORKFLOW_REF%%@*}")"
          runs_json="$(gh api "repos/${GITHUB_REPOSITORY}/actions/workflows/${wf_file}/runs?per_page=30")"

          read -r consecutive last_failed_at <<EOF
          $(echo "$runs_json" | jq -r --argjson current "$GITHUB_RUN_ID" '
            reduce (
              [ .workflow_runs[]
                | select(.id != $current)
                | select(.status == "completed")
              ][]
            ) as $r (
              {"count":0,"last_failed_at":null,"stopped":false};
              if .stopped then .
              elif ($r.conclusion == "failure") then
                {
                  "count": (.count + 1),
                  "last_failed_at": (.last_failed_at // $r.updated_at),
                  "stopped": false
                }
              else
                {
                  "count": .count,
                  "last_failed_at": .last_failed_at,
                  "stopped": true
                }
              end
            ) | "\(.count) \(.last_failed_at // "none")"
          ')
          EOF

          if [ "$consecutive" -ge "$FAILURE_THRESHOLD" ] && [ "$last_failed_at" != "none" ]; then
            now_epoch="$(date -u +%s)"
            fail_epoch="$(date -u -d "$last_failed_at" +%s)"
            elapsed_min="$(( (now_epoch - fail_epoch) / 60 ))"
            if [ "$elapsed_min" -lt "$COOLDOWN_MINUTES" ]; then
              echo "should_run=false" >> "$GITHUB_OUTPUT"
              echo "reason=cooldown_active_${elapsed_min}m_after_${consecutive}_failures" >> "$GITHUB_OUTPUT"
              exit 0
            fi
          fi

          echo "should_run=true" >> "$GITHUB_OUTPUT"
          echo "reason=gate_open" >> "$GITHUB_OUTPUT"

  select-issue:
    needs: circuit-breaker
    if: needs.circuit-breaker.outputs.should_run == 'true'
    runs-on: ubuntu-latest
    outputs:
      should_run: ${{ steps.pick.outputs.should_run }}
      issue_number: ${{ steps.pick.outputs.issue_number }}
      issue_title: ${{ steps.pick.outputs.issue_title }}
      issue_url: ${{ steps.pick.outputs.issue_url }}
    steps:
      - name: Select next issue
        id: pick
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          GH_REPO: ${{ github.repository }}
          INPUT_ISSUE_NUMBER: ${{ inputs.issue_number }}
          GH_PAGER: cat
          PAGER: cat
        shell: bash
        run: |
          set -euo pipefail

          if [ -n "${INPUT_ISSUE_NUMBER:-}" ]; then
            ISSUE_JSON="$(gh issue view "$INPUT_ISSUE_NUMBER" --json number,title,url,state,labels)"
            STATE="$(echo "$ISSUE_JSON" | jq -r '.state')"
            HAS_FROZEN="$(echo "$ISSUE_JSON" | jq -r '[.labels[].name] | any(. == "frozen")')"
            HAS_FAILED="$(echo "$ISSUE_JSON" | jq -r '[.labels[].name] | any(. == "auto-fix-failed")')"
            if [ "$STATE" != "OPEN" ] || [ "$HAS_FROZEN" = "true" ] || [ "$HAS_FAILED" = "true" ]; then
              echo "Specified issue is not eligible for auto-fix."
              echo "should_run=false" >> "$GITHUB_OUTPUT"
              exit 0
            fi
            echo "should_run=true" >> "$GITHUB_OUTPUT"
            echo "issue_number=$(echo "$ISSUE_JSON" | jq -r '.number')" >> "$GITHUB_OUTPUT"
            echo "issue_title=$(echo "$ISSUE_JSON" | jq -r '.title')" >> "$GITHUB_OUTPUT"
            echo "issue_url=$(echo "$ISSUE_JSON" | jq -r '.url')" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          OPEN_PR_ISSUES_JSON="$(
            gh pr list --state open --limit 200 --json title \
            | jq -c '
                map(
                  .title
                  | capture("^\\[AUTOFIX\\]\\[ISSUE-(?<id>[0-9]+)\\]")?
                  | .id?
                  | select(. != null)
                  | tonumber
                )
                | unique
              '
          )"

          ISSUES_JSON="$(gh issue list --state open --limit 100 --json number,title,url,labels)"

          BEST="$(echo "$ISSUES_JSON" | jq -r '
            map(
              .label_names = [.labels[].name]
              | .priority = (
                  if (.label_names | index("p0")) then 0
                  elif (.label_names | index("p1")) then 1
                  elif (.label_names | index("p2")) then 2
                  elif (.label_names | index("p3")) then 3
                  else 99
                  end
                )
            )
            | map(select((.label_names | index("frozen")) | not))
            | map(select((.label_names | index("auto-fix-failed")) | not))
            | map(select((.number as $n | $busy | index($n)) | not))
            | sort_by(.priority, .number)
            | .[0] // empty
          ' --argjson busy "$OPEN_PR_ISSUES_JSON")"

          if [ -z "$BEST" ]; then
            echo "No eligible issue found."
            echo "should_run=false" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          echo "should_run=true" >> "$GITHUB_OUTPUT"
          echo "issue_number=$(echo "$BEST" | jq -r '.number')" >> "$GITHUB_OUTPUT"
          echo "issue_title=$(echo "$BEST" | jq -r '.title')" >> "$GITHUB_OUTPUT"
          echo "issue_url=$(echo "$BEST" | jq -r '.url')" >> "$GITHUB_OUTPUT"

  generate-candidates:
    needs: [circuit-breaker, select-issue]
    if: needs.select-issue.outputs.should_run == 'true'
    runs-on: ubuntu-latest
    timeout-minutes: 60
    strategy:
      fail-fast: false
      matrix:
        candidate_id: [1, 2, 3]
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Generate candidate PR with Claude
        uses: anthropics/claude-code-action@v1
        with:
          anthropic_api_key: ${{ secrets.ANTHROPIC_API_KEY }}
          github_token: ${{ secrets.GITHUB_TOKEN }}
          prompt: |
            You are candidate #${{ matrix.candidate_id }} for fixing issue #${{ needs.select-issue.outputs.issue_number }}.
            First, load and follow the local skill at `.claude/skills/flywheel-candidate-fix/SKILL.md`.

            Issue:
            - Number: #${{ needs.select-issue.outputs.issue_number }}
            - Title: ${{ needs.select-issue.outputs.issue_title }}
            - URL: ${{ needs.select-issue.outputs.issue_url }}

            Required output:
            1. Implement a focused fix using TDD:
               - Add or update a failing regression test first.
               - Implement minimal fix.
               - Run `uv run pytest ...` and `uv run ruff check ...` on changed scope.
            2. Create a branch with EXACT name:
               `claude/issue-${{ needs.select-issue.outputs.issue_number }}-candidate-${{ matrix.candidate_id }}-${{ github.run_id }}`
            3. Commit using conventional commits and include issue number.
            4. Create ONE PR to `master` with EXACT title prefix:
               `[AUTOFIX][ISSUE-${{ needs.select-issue.outputs.issue_number }}][CANDIDATE-${{ matrix.candidate_id }}]`
               followed by a short summary.
            5. PR body must include:
               - Summary of change
               - Tests run
               - Risks/limitations
               - `Closes #${{ needs.select-issue.outputs.issue_number }}`
            6. Never push directly to master.
            7. If blocked, comment on the issue with reason and add label `auto-fix-failed` if label exists.

            Constraints:
            - Keep diff small and reviewable.
            - Do not modify workflows or secrets.
          claude_args: |
            --max-turns 20
            --model "${{ secrets.ANTHROPIC_MODEL }}"
            --allowedTools "Edit,MultiEdit,Write,Read,Glob,Grep,LS,Bash(git:*),Bash(gh:*),Bash(uv run pytest:*),Bash(uv run ruff:*)"

      - name: Quality gate candidate PR
        id: quality_gate
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          ISSUE_NUMBER: ${{ needs.select-issue.outputs.issue_number }}
          CANDIDATE_ID: ${{ matrix.candidate_id }}
          RUN_ID: ${{ github.run_id }}
          MIN_SCORE: ${{ inputs.candidate_quality_min_score || '70' }}
          GH_PAGER: cat
          PAGER: cat
        shell: bash
        run: |
          set -euo pipefail

          branch="claude/issue-${ISSUE_NUMBER}-candidate-${CANDIDATE_ID}-${RUN_ID}"
          pr_number="$(gh pr list --head "$branch" --state open --json number --jq '.[0].number // empty')"

          if [ -z "$pr_number" ]; then
            echo "status=no_pr" >> "$GITHUB_OUTPUT"
            echo "score=0" >> "$GITHUB_OUTPUT"
            echo "reason=no_open_pr_found_for_branch" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          pr_json="$(gh pr view "$pr_number" --json number,url,body,isDraft,changedFiles,additions,deletions,statusCheckRollup,files)"

          changed_files="$(echo "$pr_json" | jq -r '.changedFiles // 0')"
          additions="$(echo "$pr_json" | jq -r '.additions // 0')"
          deletions="$(echo "$pr_json" | jq -r '.deletions // 0')"
          total_delta=$((additions + deletions))
          is_draft="$(echo "$pr_json" | jq -r '.isDraft')"

          tests_touched="$(echo "$pr_json" | jq -r '
            [.files[].path
             | test("(^tests/|/tests/|^test_.*\\.py$|_test\\.py$|/test_.*\\.py$)")]
            | any
          ')"

          checks_ok="$(echo "$pr_json" | jq -r '
            ([.statusCheckRollup[]?
              | if has("conclusion") then .conclusion
                elif has("state") then .state
                else "SUCCESS" end
            ]
            | all(. == "SUCCESS" or . == "NEUTRAL" or . == "SKIPPED"))
          ')"

          body="$(echo "$pr_json" | jq -r '.body // ""')"
          has_summary="false"
          has_tests_run="false"
          has_risks="false"
          if echo "$body" | grep -qi "summary"; then has_summary="true"; fi
          if echo "$body" | grep -qi "tests run"; then has_tests_run="true"; fi
          if echo "$body" | grep -qi "risks/limitations"; then has_risks="true"; fi

          score=100

          if [ "$changed_files" -gt 20 ]; then
            score=$((score - 35))
          elif [ "$changed_files" -gt 12 ]; then
            score=$((score - 20))
          fi

          if [ "$total_delta" -gt 600 ]; then
            score=$((score - 25))
          elif [ "$total_delta" -gt 300 ]; then
            score=$((score - 15))
          fi

          if [ "$tests_touched" != "true" ]; then
            score=$((score - 20))
          fi

          if [ "$has_summary" != "true" ]; then
            score=$((score - 8))
          fi
          if [ "$has_tests_run" != "true" ]; then
            score=$((score - 8))
          fi
          if [ "$has_risks" != "true" ]; then
            score=$((score - 8))
          fi

          if [ "$is_draft" = "true" ]; then
            score=$((score - 40))
          fi

          if [ "$checks_ok" != "true" ]; then
            score=$((score - 30))
          fi

          if [ "$score" -lt 0 ]; then score=0; fi
          if [ "$score" -gt 100 ]; then score=100; fi

          gate_status="passed"
          gate_reason="meets_quality_threshold"
          if [ "$score" -lt "$MIN_SCORE" ]; then
            gate_status="failed"
            gate_reason="score_${score}_below_threshold_${MIN_SCORE}"
            gh pr comment "$pr_number" --body "Auto quality gate rejected this candidate (score: $score, threshold: $MIN_SCORE). This PR is closed to reduce low-quality candidate noise."
            gh pr close "$pr_number" || true
          fi

          echo "status=$gate_status" >> "$GITHUB_OUTPUT"
          echo "score=$score" >> "$GITHUB_OUTPUT"
          echo "reason=$gate_reason" >> "$GITHUB_OUTPUT"
          echo "pr_number=$pr_number" >> "$GITHUB_OUTPUT"
          echo "pr_url=$(echo "$pr_json" | jq -r '.url')" >> "$GITHUB_OUTPUT"

      - name: Candidate summary
        if: always()
        run: |
          echo "### Candidate Run" >> "$GITHUB_STEP_SUMMARY"
          echo "- Circuit breaker: ${{ needs.circuit-breaker.outputs.reason }}" >> "$GITHUB_STEP_SUMMARY"
          echo "- Issue: #${{ needs.select-issue.outputs.issue_number }}" >> "$GITHUB_STEP_SUMMARY"
          echo "- Candidate: ${{ matrix.candidate_id }}" >> "$GITHUB_STEP_SUMMARY"
          echo "- Title: ${{ needs.select-issue.outputs.issue_title }}" >> "$GITHUB_STEP_SUMMARY"
          echo "- Quality gate status: ${{ steps.quality_gate.outputs.status }}" >> "$GITHUB_STEP_SUMMARY"
          echo "- Quality gate score: ${{ steps.quality_gate.outputs.score }}" >> "$GITHUB_STEP_SUMMARY"
          echo "- Quality gate reason: ${{ steps.quality_gate.outputs.reason }}" >> "$GITHUB_STEP_SUMMARY"
          echo "- Candidate PR: #${{ steps.quality_gate.outputs.pr_number }} ${{ steps.quality_gate.outputs.pr_url }}" >> "$GITHUB_STEP_SUMMARY"
