{
  "issue_number": 2536,
  "candidate_number": 3,
  "run_id": "21831630514",
  "branch_name": "claude/issue-2536-candidate-3-21831630514",
  "stage": "IMPLEMENT",
  "tdd_plan": {
    "description": "Add file locking for concurrent write safety using the filelock library",
    "files_to_touch": [
      "pyproject.toml",
      "src/flywheel/storage.py",
      "tests/test_storage_locking.py"
    ],
    "implementation_sequence": [
      {
        "step": 1,
        "phase": "RED",
        "action": "Add failing test for file locking timeout",
        "details": "Test that acquiring a lock with timeout raises TimeoutError when lock is held by another process"
      },
      {
        "step": 2,
        "phase": "RED",
        "action": "Add failing test for concurrent write blocking",
        "details": "Test that save() blocks when another process holds exclusive lock"
      },
      {
        "step": 3,
        "phase": "RED",
        "action": "Add failing test for lock release on exception",
        "details": "Test that lock is released even when save() raises an exception"
      },
      {
        "step": 4,
        "phase": "GREEN",
        "action": "Add filelock dependency to pyproject.toml",
        "details": "Add 'filelock>=3.16.0' to dependencies"
      },
      {
        "step": 5,
        "phase": "GREEN",
        "action": "Implement FileLock context manager in storage.py",
        "details": "Add _acquire_lock() and _release_lock() methods using filelock.FileLock"
      },
      {
        "step": 6,
        "phase": "GREEN",
        "action": "Wrap save() with exclusive lock",
        "details": "Acquire exclusive lock before writing, release after os.replace"
      },
      {
        "step": 7,
        "phase": "GREEN",
        "action": "Wrap load() with shared lock (using exclusive for compatibility)",
        "details": "Acquire lock during read to prevent concurrent modification"
      },
      {
        "step": 8,
        "phase": "GREEN",
        "action": "Add timeout parameter with default 5 seconds",
        "details": "Configure FileLock with timeout=5, catch TimeoutError and re-raise with clear message"
      }
    ],
    "verification_commands": [
      "uv run pytest tests/test_storage_locking.py -v",
      "uv run pytest tests/test_storage_atomicity.py -v",
      "uv run ruff check src/flywheel/storage.py tests/test_storage_locking.py"
    ]
  },
  "acceptance_criteria": [
    "save() acquires exclusive lock before writing, releases after completion",
    "load() acquires lock during read to prevent concurrent modification",
    "Lock acquisition fails with clear error after configurable timeout (default 5s)",
    "Cross-platform: works on Linux (fcntl) and Windows (msvcrt.locking) via filelock"
  ],
  "risks": [
    "Performance overhead from lock acquisition on every save/load",
    "Deadlock potential if timeout is too long",
    "filelock library may have edge cases on certain filesystems (NFS, SMB)"
  ],
  "status": "verified",
  "verification_results": {
    "pytest_locking": "6/6 passed in 0.35s",
    "pytest_atomicity": "6/6 passed in 0.09s",
    "ruff_check": "All checks passed",
    "timestamp": "2026-02-09T00:00:00Z"
  }
}
